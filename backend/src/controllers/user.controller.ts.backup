import { Response } from 'express';
import { AuthRequest } from '../middlewares/auth.middleware';
import { AppDataSource } from '../database/connection';
import { User } from '../models/User.model';
import { Profile } from '../models/Profile.model';
import { UserPreference } from '../models/UserPreference.model';
import { Property } from '../models/Property.model';
import { successResponse, errorResponse } from '../utils/response.util';

export const getProfile = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    const userRepository = AppDataSource.getRepository(User);
    const user = await userRepository.findOne({
      where: { id: userId },
      relations: ['profile'],
    });

    if (!user) {
      errorResponse(res, 'User not found', 404);
      return;
    }

    successResponse(res, {
      user: {
        id: user.id,
        email: user.email,
        phone: user.phone,
        role: user.role,
        profileType: user.profileType,
        whatsappNumber: user.whatsappNumber,
        isEmailVerified: user.isEmailVerified,
        isPhoneVerified: user.isPhoneVerified,
        isVerified: user.isVerified,
        isActive: user.isActive,
        lastLogin: user.lastLogin,
        createdAt: user.createdAt,
        profile: user.profile,
      },
    }, 'Profile fetched successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const updateProfile = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;
    const { name, bio, location, avatar, company, website } = req.body;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    const profileRepository = AppDataSource.getRepository(Profile);
    let profile = await profileRepository.findOne({
      where: { userId },
    });

    if (!profile) {
      // Create profile if it doesn't exist
      profile = profileRepository.create({
        userId,
        name,
        bio,
        location,
        avatar,
        company,
        website,
      });
    } else {
      // Update existing profile
      if (name !== undefined) profile.name = name;
      if (bio !== undefined) profile.bio = bio;
      if (location !== undefined) profile.location = location;
      if (avatar !== undefined) profile.avatar = avatar;
      if (company !== undefined) profile.company = company;
      if (website !== undefined) profile.website = website;
    }

    await profileRepository.save(profile);

    successResponse(res, { profile }, 'Profile updated successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const updatePreferences = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;
    const {
      propertyTypes,
      minPrice,
      maxPrice,
      locations,
      amenities,
      notificationSettings,
    } = req.body;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    const preferencesRepository = AppDataSource.getRepository(UserPreference);
    let preferences = await preferencesRepository.findOne({
      where: { userId },
    });

    if (!preferences) {
      // Create preferences if they don't exist
      preferences = preferencesRepository.create({
        userId,
        propertyTypes,
        minPrice,
        maxPrice,
        locations,
        amenities,
        notificationSettings,
      });
    } else {
      // Update existing preferences
      if (propertyTypes !== undefined) preferences.propertyTypes = propertyTypes;
      if (minPrice !== undefined) preferences.minPrice = minPrice;
      if (maxPrice !== undefined) preferences.maxPrice = maxPrice;
      if (locations !== undefined) preferences.locations = locations;
      if (amenities !== undefined) preferences.amenities = amenities;
      if (notificationSettings !== undefined) preferences.notificationSettings = notificationSettings;
    }

    await preferencesRepository.save(preferences);

    successResponse(res, { preferences }, 'Preferences updated successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const getPreferences = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    const preferencesRepository = AppDataSource.getRepository(UserPreference);
    const preferences = await preferencesRepository.findOne({
      where: { userId },
    });

    if (!preferences) {
      // Return default preferences if none exist
      successResponse(res, {
        preferences: {
          propertyTypes: [],
          minPrice: null,
          maxPrice: null,
          locations: [],
          amenities: [],
          notificationSettings: {},
        },
      }, 'No preferences found');
      return;
    }

    successResponse(res, { preferences }, 'Preferences fetched successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const submitSurvey = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;
    const surveyData = req.body;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    // Extract preference data from survey
    const {
      propertyTypes,
      priceRange,
      preferredLocations,
      mustHaveAmenities,
      notificationPreferences,
    } = surveyData;

    const preferencesRepository = AppDataSource.getRepository(UserPreference);
    let preferences = await preferencesRepository.findOne({
      where: { userId },
    });

    if (!preferences) {
      preferences = preferencesRepository.create({
        userId,
        propertyTypes: propertyTypes || [],
        minPrice: priceRange?.min || null,
        maxPrice: priceRange?.max || null,
        locations: preferredLocations || [],
        amenities: mustHaveAmenities || [],
        notificationSettings: notificationPreferences || {},
      });
    } else {
      preferences.propertyTypes = propertyTypes || preferences.propertyTypes;
      preferences.minPrice = priceRange?.min || preferences.minPrice;
      preferences.maxPrice = priceRange?.max || preferences.maxPrice;
      preferences.locations = preferredLocations || preferences.locations;
      preferences.amenities = mustHaveAmenities || preferences.amenities;
      preferences.notificationSettings = notificationPreferences || preferences.notificationSettings;
    }

    await preferencesRepository.save(preferences);

    successResponse(res, { preferences }, 'Survey submitted successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const getUserStatistics = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    const propertyRepository = AppDataSource.getRepository(Property);

    // Get user's properties count
    const propertiesCount = await propertyRepository.count({
      where: { listerId: userId },
    });

    // Get active properties count
    const activePropertiesCount = await propertyRepository.count({
      where: { listerId: userId, status: 'active' },
    });

    // TODO: Add more statistics (views, favorites, messages, etc.)

    successResponse(res, {
      statistics: {
        totalProperties: propertiesCount,
        activeProperties: activePropertiesCount,
        inactiveProperties: propertiesCount - activePropertiesCount,
        // Add more stats as needed
      },
    }, 'Statistics fetched successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const deleteAccount = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;
    const { password } = req.body;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    if (!password) {
      errorResponse(res, 'Password is required to delete account', 400);
      return;
    }

    const userRepository = AppDataSource.getRepository(User);
    const user = await userRepository.findOne({
      where: { id: userId },
    });

    if (!user) {
      errorResponse(res, 'User not found', 404);
      return;
    }

    // Verify password
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      errorResponse(res, 'Invalid password', 401);
      return;
    }

    // Soft delete: deactivate account instead of deleting
    user.isActive = false;
    await userRepository.save(user);

    // TODO: Optionally, delete or anonymize user data

    successResponse(res, {}, 'Account deleted successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};

export const updatePassword = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;
    const { currentPassword, newPassword } = req.body;

    if (!userId) {
      errorResponse(res, 'User not authenticated', 401);
      return;
    }

    if (!currentPassword || !newPassword) {
      errorResponse(res, 'Current password and new password are required', 400);
      return;
    }

    if (newPassword.length < 6) {
      errorResponse(res, 'New password must be at least 6 characters', 400);
      return;
    }

    const userRepository = AppDataSource.getRepository(User);
    const user = await userRepository.findOne({
      where: { id: userId },
    });

    if (!user) {
      errorResponse(res, 'User not found', 404);
      return;
    }

    // Verify current password
    const isPasswordValid = await user.comparePassword(currentPassword);
    if (!isPasswordValid) {
      errorResponse(res, 'Current password is incorrect', 401);
      return;
    }

    // Update password
    user.password = newPassword; // Will be hashed by @BeforeUpdate hook
    await userRepository.save(user);

    successResponse(res, {}, 'Password updated successfully');
  } catch (error: any) {
    errorResponse(res, error.message, 500);
  }
};
